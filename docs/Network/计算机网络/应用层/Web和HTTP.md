---
title: Web和HTTP
id: 2
---


Web页由一些**对象**组成，对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等

Web页含有一个基本的HTML文件，该基本HTML文件又包含若干对象的引用（链接）

通过URL对每个对象进行引用，URL包含访问协议，用户名，口令字，端口等；

Prot:（协议名）//user:psw（用户，口令）@www.someSchool.edu（主机名）/someDept（路径名）/pic.gif（文件名）:port（端口号）



### HTTP概况

HTTP: 超文本传输协议

- Web的应用层协议

- 客户/服务器模式

  - 客户: 请求、接收和显示 Web对象的浏览器
  - 服务器: 对请求进行响应，发送对象的Web服务器

  ![image-20210807145628882](/img/Network/计算机网络/应用层/image-20210807145628882.png)

- HTTP 1.0：RFC 1945

- HTTP 1.1：RFC 2068



HTTP使用TCP协议

- 客户发起一个与服务器的 TCP连接 (建立套接字) ， 端口号为 80
- 服务器接受客户的TCP连接
- 在浏览器（HTTP客户端）与 Web服务器(HTTP服务器 server)交换HTTP 报文（应用层协议报文）
- TCP连接关闭

**HTTP是无状态的，即服务器并不维护关于客户的任何信息**

> 维护状态的协议很复杂
>
> - 必须维护历史信息(状态)
> - 如果服务器/客户端死机，它们的状态信息可能不一致， 然而二者的信息必须是一致的
> - 无状态的服务器能够支持更多的客户端



### HTTP连接

#### 非持久HTTP

- 最多只有一个对象在 TCP连接上发送
- 下载多个对象需要多个TCP连接
- HTTP/1.0使用非持久连接

![image-20210807145628882](/img/Network/计算机网络/应用层/image-20210807150925859.png)

**响应时间模型**

往返时间RTT（round-trip  time）：一个小的分组从客户端到服务器，在回到客户端的时间（传输时间忽略） 

响应时间

- 一个  RTT用来发起TCP连接
- 一个 RTT用来HTTP请求并等待HTTP响应
- 文件传输时间
  - **共2RTT+传输时间**



非持久HTTP的缺点

- 每个对象要2个 RTT
- 操作系统必须为每个TCP连接分配资源
- 浏览器通常打开并行TCP连接，以获取引用对象



#### 持久HTTP

- 多个对象可以在一个 （在客户端和服务器之间的）TCP连接上传输
- HTTP/1.1 默认使用持久连接
- 服务器在发送响应后，仍保持 TCP连接
- 在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送
- 客户端在遇到一个引用对象的 候，就可以尽快发送该对象的请 求



非流水方式的持久HTTP

- 客户端只能在收到前一个响应后才能发出新的请求
- 每个引用对象花费一个RTT

流水方式的持久HTTP

- HTTP/1.1的默认模式
- 客户端遇到一个引用对象就立即产生一个请求
- 所有引用（小）对象只花费一个 RTT是可能的





### HTTP报文

两种类型的HTTP报文：请求、响应



#### HTTP请求报文

- ASCII（人能够阅读）

  ```ASCII
  GET /somedir/page.html HTTP/1.1                 请求行 (GET, POST, HEAD，PUT，DELETE命令)
  Host: www.someschool.edu  						首部行     主机名
  User-agent: Mozilla/4.0 						首部行     用户代理程序，浏览器版本
  Connection: close  								首部行		连接关闭
  Accept-language:fr  							首部行	    语言
  												换行回车符，表示报文结束
  ```

- 报文格式

  ![image-20210807153452542](/img/Network/计算机网络/应用层/image-20210807153452542.png)

- 提交表单输入

  - Post方式

    - 网页通常包括表单输入
    - 包含在实体主体 (entity body )中的输入被提交到服务器

  - GET方式

    - 通过请求行的 URL字段输入数据上载

    - 如

      ![image-20210807153452542](/img/Network/计算机网络/应用层/image-20210807153816852.png)


- 方法类型

  - HTTP/1.0

    - GET

    - POST

    - HEAD

      > 要求服务器在响应报文中不包含请求对象，通常用于调试跟踪或搜索引擎建立索引

  - HTTP/1.1

    - GET, POST, HEAD

    - PUT

      > 将实体主体中的文件上载到URL字段规定的路径

    - DELETE

      > 删除URL字段规定的文件

    

#### HTTP响应报文

- ASCII

  ```ASCII
  HTTP/1.1 200 OK\r\n								状态行 (协议版本、状态码和相应状态信息)
  Connection close\r\n							首部行 	连接关闭
  Date: Thu, 06 Aug 1998 12:00:15 GMT\r\n			首部行 	日期和时间
  Server: Apache/1.3.0 (Unix) \r\n				首部行 	服务器类型版本
  Last-Modified: Mon, 22 Jun 1998 …... \r			首部行 	最后修改时间
  Content-Length: 6821\r\n						首部行 	内容字节长度
  Content-Type: text/html\r\n						首部行 	对象类型，此次指示位HTML文本
  	\r\n
  	\r\n
  data data data data data ... 					实体主体
  ```

- 响应状态码

  - 200 OK

    > 请求成功，请求对象包含在响应报文的后续部分 

  - 301 Moved Permanently

    > 请求的对象已经被永久转移了；新的URL在响应报文的Location: 首部行中指定
    >
    > 客户端软件自动用新的URL去获取对象 

  - 400 Bad Request

    > 一个通用的差错代码，表示该请求不能被服务器解读 

  - 404 Not Found

    > 请求的文档在该服务上没有找到

  - 505 HTTP Version Not Supported

    > 服务器不支持请求报文使用的HTTP协议版本

  



### 用户-服务器状态：cookie

大多数主要的门户网站使用 cookies

cookies有4个组成部分

1. 在HTTP响应报文中有一个cookie的首部行
2. 在HTTP请求报文含有一个cookie的首部行
3. 在用户端系统中保留有一个cookie文件，由用户的浏览器管理
4. 在Web站点有一个后端数据库



Cookie维护状态过程

![image-20210807160055822](/img/Network/计算机网络/应用层/image-20210807160055822.png)

如何维持状态

- 协议端节点：在多个事务上，发送端和接收端维持状态
- cookies：HTTP报文携带状态信息



Cookies与隐私

- Cookies允许站点知道许多关于用户的信息
- 可能将它知道的东西卖给第三方
- 使用重定向和cookie的搜索引擎还能知道用户更多的信息
- 如通过某个用户在大量站点上的行为，了解其个人浏览方式的大致模式
- 广告公司从站点获得信息





### Web缓存（代理服务器）

目标：不访问原始服务器，就满足客户的请求

- 用户设置浏览器： 通过缓存访问Web
- 浏览器将所有的HTTP请求发给缓存
  - 在缓存中的对象：缓存直接返回对象
  - 如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端
- 缓存既是客户端又是服务器
- 通常缓存是由ISP安装 (大学、公司、居民区ISP)



使用Web缓存的优点

- 降低客户端的请求响应时间
- 可以大大减少一个机构内部网络与Internet接入链路上的流量
- 互联网大量采用了缓存： 可以使较弱的ICP也能够有效提供内容



**缓存示例**

假设

- 平均对象大小 = 100kb
- 机构内浏览器对原始服务器的平均请求率为 = 15请求/s
- 平均到浏览器的速率：1.5Mbps
- 机构内部路由器到原始服务器再返回到路由器的延时（ Internet 延时）= 2s
- 接入链路带宽：1.54Mbps
- 局域网带宽：1Gbps

结果

- LAN的流量强度 =（15个请求/s）$\times$ （100kb/请求）/（1Gbps）= 15%
- 接入链路上的流量强度（15个请求/s）$\times$ （100kb/请求）/（1.54Mbps）=  99%
- 总延时 = LAN延时 + 接入延时 + Internet 延时 = ms + 分 + 2s，耗时太长，减少耗时可以采用提高宽带的方法



利用缓存减少耗时，计算链路利用率，有缓存的延迟

- 假设缓存命中率0.4
- 40%请求在缓存中被满足，其他60%的请求需要被原始服务器满足

则接入链路利用率

- 60%的请求采用接入链路
- 流量强度=（15个请求/s）$\times$ （100kb/请求）$\times$ 0,6/1.54 =0.58，则排队延时为毫秒级
- 总体延迟= 0.6 * (从原始服务器获取对象的延迟) +0.4 * (从缓存获取对象的延迟) = 0.6$\times$(10ms+排队延时+2s) + 0.4$\times$(毫秒级)  $\approx$1.2s
- 比安装154Mbps链路延时小且比较便宜



### 条件GET方法

目标：若缓存器中的对象拷贝是最新的，就不要发送对象

缓存器: 在HTTP请求中指定缓存拷贝的日期![image-20210807165731990](/img/Network/计算机网络/应用层/image-20210807165731990.png)

服务器: 如果缓存拷贝陈旧，则响应报文没包含对象![image-20210807165752140](/img/Network/计算机网络/应用层/image-20210807165752140.png)

![image-20210807165843009](/img/Network/计算机网络/应用层/image-20210807165843009.png)



