---
title: 可靠数据传输（rdt）原理
id: 4
---

rdt（可靠数据传输协议）在应用层、传输层和数据链路层都很重要

信道的不可靠特点决定了可靠数据传输协议的复杂性

服务实现模型：

![image-20210820075814869](/img/Network/计算机网络/传输层/image-20210820075814869.png)

可靠数据传输：问题描述

- 渐增式地开发可靠数据传输协议（ rdt ）的发送方和接收方

- 只考虑单向数据传输，但控制信息是双向流动的

- 双向的数据传输问题实际上是2个单向数据传输问题的综合

- 使用有限状态机 (FSM) 来描述发送方和接收方

  > 有限状态机是一种描述形式
  >
  > ![image-20210820080351026](/img/Network/计算机网络/传输层/image-20210820080351026.png)



Rdt1.0： 在可靠信道上的可靠数据传输

- 下层的信道是完全可靠的

  - 没有比特出错
  - 没有分组丢失

- 发送方和接收方的FSM

  - 发送方将数据封装发送到下层信道

  - 接收方从下层信道接收数据，解封装

    ![image-20210820080540803](/img/Network/计算机网络/传输层/image-20210820080540803.png)



Rdt2.0：具有比特差错的信道

- 下层信道可能会出错：将分组中的比特翻转

  - 用校验和来检测比特差错

- 问题：怎样从差错中恢复

  - 确认（ACK）：接收方显式地告诉发送方分组已被正确接收
  - 否定确认（NAK）: 接收方显式地告诉发送方分组发生了差错
    - 发送方收到NAK后，发送方重传分组

- rdt2.0中的新机制：采用差错控制编码进行差错检测

  - 发送方差错控制编码、缓存
  - 接收方使用编码检错
  - 接收方的反馈：控制报文（ACK，NAK），由接收方发给发送方
  - 发送方收到反馈相应的动作

- 基于这样重传机制的可靠数据传输协议称为自动重传请求（ARQ）协议

- FSM描述

  ![image-20210820081615213](/img/Network/计算机网络/传输层/image-20210820081615213.png)



rdt2.0存在致命缺陷则 -> rdt2.1

如果ACK/NAK出错？

- 发送方不知道接收方发生了什么事情
- 发送方如何做
  - 若重传可能重复
  - 若不重传可能死锁(或出错) 
- 需要引入新的机制：序号

处理重复

- 发送方在每个分组中加入序号
- 如果ACK/NAK出错，发送方重传当前分组
- 接收方丢弃（不发给上层）重复分组

停止等待协议：发送方发送一个分组， 然后等待接收方的应答

FSM描述：

- 发送方处理出错的ACK/NAK

  ![image-20210820082340128](/img/Network/计算机网络/传输层/image-20210820082340128.png)

- 接收方处理出错的ACK/NAK

  ![image-20210820082514757](/img/Network/计算机网络/传输层/image-20210820082514757.png)

rdt2.1发送方

- 在分组中加入序列号
- 两个序列号（0，1）就足够了
  - 一次只发送一个未经确认的分组
- 必须检测ACK/NAK是否出错（需要EDC）
- 状态数变成了两倍
  - 必须记住当前分组的序列号为0还是1

rdt2.1接收方

- 必须检测接收到的分组是否是重复的
  - 状态会指示希望接收到的分组的序号为0还是1
- 注意：接收方并不知道发送方是否正确收到了其ACK/NAK
  - 没有安排确认的确认



rdt2.1运行过程：

![image-20210820083417442](/img/Network/计算机网络/传输层/image-20210820083417442.png)

接收方不知道它最后发送的ACK/NAK是否被正确地收到

- 发送方不对收到的ack/nak给确认，没有所谓的确认的确认
- 接收方发送ack，如果后面接收方收到的是
  - 老分组p0，则ack 错误
  - 下一个分组P1，则ack正确



rdt2.2：无NAK（NAK free）的协议

- 功能同rdt2.1，但只使用ACK(ack 要编号）

- 接收方对**最后**正确接收的分组发ACK，以替代NAK

  - 接收方必须显式地包含被正确接收分组的序号

- 当收到重复的ACK（如：再次收到ack0）时，发送方与收到NAK采取相同的动作：重传当前分组

- 为后面的一次发送多个数据单位做一个准备

  - 一次能够发送多个
  - 使用对前一个数据单位的ACK，代替本数据单位的NAK
  - 确认信息减少一半，协议处理简单

- 运行过程

  ![image-20210820083926717](/img/Network/计算机网络/传输层/image-20210820083926717.png)



rdt3.0：具有比特差错和分组丢失的信道

问题：若下层信道可能会丢失分组（数据或ACK）

解决方法：发送方等待ACK一段合理的时间

> 链路层的timeout时间确定的 
>
> 传输层timeout时间是适应式的

- 发送端超时重传：如果到时没有收到ACK则重传
- 问题：如果分组（或ACK ）只是被延迟了
  - 重传将会导致数据重复，但利用序列号可以处理这个问题
  - 接收方必须指明被正确接收的序列号
- 需要一个倒计数定时器

rdt3.0发送方FSM描述：

![image-20210820084716025](/img/Network/计算机网络/传输层/image-20210820084716025.png)

rdt3.0运行过程

![image-20210820084743656](/img/Network/计算机网络/传输层/image-20210820084743656.png)

![image-20210820084813574](/img/Network/计算机网络/传输层/image-20210820084813574.png)

- 过早超时（延迟的ACK）也能够正常工作；但是效率较低，一半的分组和确认是重复的
- 设置一个合理的超时时间是比较重要的



**rdt3.0的性能**

rdt3.0可以工作，但链路容量比较大的情况下，性能很差

- 链路容量比较大，一次发一个PDU的不能够充分利用链路的传输能力

<br/>![image-20210820090145229](/img/Network/计算机网络/传输层/image-20210820090145229.png)

- $U_{sender}$：利用率，即忙于发送的时间比例
- 每30ms发送1KB的分组 -->270kbps=33.75kB/s 的吞吐量（在1Gbps 链路上）
- 瓶颈在于：网络协议限制了物理资源的利用

- 此例子体现了rdt3.0的停-等操作

![image-20210820090616698](/img/Network/计算机网络/传输层/image-20210820090616698.png)



- 通过流水线提高链路利用率，下图展示同时发送3个分组的情况

  ![image-20210820090917997](/img/Network/计算机网络/传输层/image-20210820090917997.png)

  - 增加n，能提高链路利用率
  - 但当达到某个n，其u=100%时，无法再通过增加n，提高利用率
  - 瓶颈变成了链路带宽



**流水线协议**

流水线：允许发送方在未得到对方确认的情况下一次发送多个分组

- 必须增加序号的范围：用多个bit表示分组的序号
- 在发送方/接收方要有缓冲区
  - 发送方缓冲：未得到确认，可能需要重传
  - 接收方缓存：上层用户取用数据的速率≠接收到的数据速率；接收到的数据可能乱序，排序交付（可靠）
- 两种通用的流水线协议：回退N步（GBN）和选择重传（SR）



滑动窗口（slide window）协议

- 发送缓冲区

  - 形式：内存中的一个区域，落入缓冲区的分组可以发送
  - 功能：用于存放已发送，但是没有得到确认的分组
  - 必要性：需要重发时可用

- 发送缓冲区的大小：一次最多可以发送多少个未经确认的分组

  - 停止等待协议=1
  - 流水线协议>1，合理的值，不能很大，链路利用率不能够超100%

- 发送缓冲区中的分组

  - 未发送的：落入发送缓冲区的分组，可以连续发送出去
  - 已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除

- 发送窗口：发送缓冲区内容的一个范围

  - 那些已发送但是未经确认分组的序号构成的空间

- 发送窗口的最大值<=发送缓冲区的值

- 一开始：没有发送任何一个分组

  - 后沿=前沿
  - 之间为发送窗口的尺寸=0

- 每发送一个分组，前沿前移一个单位；发送窗口前沿移动的极限：不能够超过发送缓冲区

  ![image-20210820091837025](/img/Network/计算机网络/传输层/image-20210820091837025.png)

- 发送窗口后沿移动

  - 条件：收到老分组的确认

  - 结果：发送缓冲区罩住新的分组，来了分组可以发送

  - 移动的极限：不能够超过前沿

    ![image-20210820092208134](/img/Network/计算机网络/传输层/image-20210820092208134.png)

- 接收窗口（Receiving Window）= 接收缓冲区

  - 接收窗口用于控制哪些分组可以接收
    - 只有收到的分组序号落入接收窗口内才允许接收
    - 若序号在接收窗口之外，则丢弃
  - 接收窗口尺寸RW=1，则只能顺序接收，即GBN协议
  - 接收窗口尺寸RW>1 ，则可以乱序接收，但提交给上层的分组，要按序，即SR协议

- 接收窗口的滑动和发送确认

  - 滑动

    - 低序号的分组到来，接收窗口移动

    - 高序号分组乱序到，缓存但不交付（因为要实现rdt，不允许失序），不滑动

  - 发送确认

    - 接收窗口尺寸=1 ； 发送连续收到的最大的分组确认（累计确认）
    - 接收窗口尺寸>1 ； 收到分组，发送那个分组的确认（非累计确认）

- 正常情况下的2个窗口互动

  - 发送窗口
    - 有新的分组落入发送缓冲区范围，发送且前沿滑动
    - 来了老的低序号分组的确认->后沿向前滑动->新的分组可以落入发送缓冲区的范围
  - 接收窗口
    - 收到分组，落入到接收窗口范围内，接收
    - 是低序号，发送确认给对方
  - 发送端上面来了分组->发送窗口滑动->接收窗口滑动->发确认

- 异常情况下GBN的2窗口互动

  - 发送窗口
    - 新分组落入发送缓冲区范围，发送->前沿滑动
    - 超时重发机制让发送端将发送窗口中的所有分组发送出去
    - 来了老分组的重复确认->后沿不向前滑动->新的分组无法落入发送缓冲区的范围（此时如果发送缓冲区有新的分组可以发送）
  - 接收窗口
    - 收到乱序分组，没有落入到接收窗口范围内，抛弃
    - （重复）发送老分组的确认，累计确认；

- 异常情况下SR的2窗口互动

  - 发送窗口
    - 新分组落入发送缓冲区范围，发送->前沿滑动
    - 超时重发机制让发送端将超时的分组重新发送出去
    - 来了乱序分组的确认->后沿不向前滑动->新的分组无法落入发送缓冲区的范围（此时如果发送缓冲区有新的分组可以发送）
  - 接收窗口
    - 收到乱序分组，落入到接收窗口范围内，接收
    - 发送该分组的确认，单独确认；



GBN协议和SR协议的异同

- 相同之处
  - 发送窗口>1
  - 一次能够可发送多个未经确认的分组
- 不同之处
  - GBN :接收窗口尺寸=1
    - 接收端：只能顺序接收
    - 发送端：从表现来看，一旦一个分组没有发成功，如：0,1,2,3,4  ; 假如1未成功，234都发送出去了，要返回1再发送；GB1
  - SR: 接收窗口尺寸>1
    - 接收端：可以乱序接收
    - 发送端：发送0,1,2,3,4，一旦1未成功，2,3,4,已发送，无需重发，选择性发送1



流水线协议总结

- Go-back-N
  - 发送端最多在流水线中有N个未确认的分组
  - 接收端只是发送累计型确认cumulative ack
    - 接收端如果发现gap， 不确认新到来的分组
  - 发送端拥有对最老的 未确认分组的定时器
    - 只需设置一个定时器
    - 当定时器到时时，重传所有未确认分组
- Selective Repeat
  - 发送端最多在流水线中有N个未确认的分组
  - 接收方对每个到来的分组单独确认individual ack （非累计确认）
  - 发送方为每个未确认的分组保持一个定时器,当超时定时器到时，只重发到时的未确认分组



GBN：发送方扩展的FSM

![image-20210820095627060](/img/Network/计算机网络/传输层/image-20210820095627060.png)

GBN：接收方扩展的FSM

![image-20210820095652709](/img/Network/计算机网络/传输层/image-20210820095652709.png)

- 只发送ACK：对顺序接收的最高序号的分组
  - 可能会产生重复的ACK
  - 只需记住expectedseqnum；接收窗口=1，只一个变量就可表示接收窗口
- 对乱序的分组
  - 丢弃（不缓存），在接收方不被缓存
  - 对顺序接收的最高序号的分组进行确认------累计确认



选择重传SR

- 接收方对每个正确接收的分组，分别发送 ACKn（非累积确认）
  - 接收窗口>1，可以缓存乱序的分组
  - 最终将分组按顺序交付给上层
- 发送方只对那些没有收到ACK的分组进行重发-选择性重发
  - 发送方为每个未确认的分组设定一个定时器
- 发送窗口的最大值（发送缓冲区）限制发送未确认分组的个数

选择重传发送方：

- 从上层接收数据，如果下一个可用于该分组的序号可在发送窗口中，则发送

- timeout(n)：重新发送分组n，重新设定定时器 
- ACK(n) in [sendbase,sendbase+N]：将分组n标记为已接收，如n为最小未确认的分组序号， 将base移到下一个未确认序号

选择重传接收方：

- 分组n [rcvbase, rcvbase+N-1]
  - 发送ACK(n)
  - 乱序：缓存
  - 有序：该分组及以前缓存的序号连续的分组交付给上层 ，然后将窗口移到下一个仍未被接收的分组
- 分组n [rcvbase-N, rcvbase-1] 
  - 发送ACK(n) 
- 其它：忽略该分组



GBN和SR

|      | GBN                                     | SR                                       |
| ---- | --------------------------------------- | ---------------------------------------- |
| 优点 | 简单，所需资源少（接收方一个 缓存单元） | 出错时，重传一个代价小                   |
| 缺点 | 一旦出错，回退N步代价大                 | 复杂，所需要资源多（接收方多个缓存单元） |

适用范围

- 出错率低：比较适合GBN，出错非常罕见，没有必要用复杂的SR，为罕见的事件做日常的准备和复杂处理
- 链路容量大（延迟大、带宽大）：比较适合SR而不是GBN，一点出错代价太大



窗口的最大尺寸，若存在n个分组

- GBN：$2^n-1$
- SR：$2^{n-1}$

