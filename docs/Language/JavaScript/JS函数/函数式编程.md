JavaScript 可以把函数作为对象来操作意味着可以在 JavaScript 中使用函数实编程技巧

### 使用函数处理数组

假设有一个数值数组，要求计算平均值和标准差，

- 使用非函数式编程风格

  ```js
  let data = [1,1,3,5,5];
  
  // 计算平均值
  let total = 0;
  for(let i = 0; i < data.length; i++) total += data[i];
  let mean = total/data.length;
  
  // 计算标准差，计算每个元素相对于平均值偏差的平方
  total = 0;
  for(let i = 0; i < data.length; i++){
      let deviation = data[i] - mean;
      total += deviation * deviation;
  }
  let stddev = Math.sqrt(total/(data.length-1));
  ```

- 使用函数式编程风格

  ```js
  // 先定义两个简单的函数
  const sum = (x,y) => x+y;
  const square = x => x*x;
  
  // 使用数组方法计算平均值和标准差
  let data = [1,1,3,5,5];
  let mean = data.reduce(sum)/data.length;    // mean == 3
  let deviations = data.map(x => x-mean);
  let stddev = Math.sqrt(deviations.map(square).reduce(sum)/(data.length-1));
  stddec          // => 2
  ```

- 定义方法的函数版

  ```js
  // 定义 map() 和 reduce() 函数
  const map = function(a,...args) { return a.map(...args);};
  const reduce = function(a,...args) { return a.reduce(...args);};
  
  // 先定义两个简单的函数
  const sum = (x,y) => x+y;
  const square = x => x*x;
  
  // 使用数组方法计算平均值和标准差
  let data = [1,1,3,5,5];
  let mean = reduce(data,sum)/data.length;    
  let deviations = map(data, x => x-mean);
  let stddev = Math.sqrt(reduce(map(deviation,square),sum)/(data.length-1));
  stddec        
  ```



### 高阶函数

高阶函数即操作函数的函数，它接收一个或多个函数作为参数并返回一个新函数

以下的 `mapper()` 函数接收一个函数参数并返回一个新函数

```js
// 返回一个函数，这个函数接收一个数组并对每个元素应用f
// 返回每个返回值的数组
// 比较这个函数与之前的map() 函数
function mapper(f){
    return a => map(a, f);
}
const increment = x => x+1;
const incrementAll = mapper(increment);
incrementAll([1,2,3])    // => [2,3,4]
```

以下这个高阶函数接收两个函数，返回一个新函数

```js
// 返回一个计算f(g(...))的新函数
// 返回的函数h会把它接收的所有参数传给g，
// 再把g的返回值传给f，然后返回f的返回值
// f和g被调用时都使用与h被调用时相同的this值
function compose(f, g){
    return function(...args){
        // 这里对f使用call是因为只给它传一个值
        // 对g使用apply是因为正在传一个值的数组
        return f.call(this, g.apply(this, args));
    };
}

const sum = (x,y) => x+y;
const square = x => x*x;
compose(square, sum)(2,3)    // => 25,平方和
```



### 函数柯里化

函数f的 `bind()` 方法返回一个新函数，这个新函数在指定的上下文中以指定的参数调用f，此时 `bind()` 方法在左侧部分应用函数，即传给 `bind()` 的参数会放在原始函数的参数列表的开头

```js
// 传给这个函数的参数会传到左侧
function partialLeft(f, ...outerArgs){
    return function(...innerArgs){                  // 返回这个函数
        let args = [...outerArgs, ...innerArgs];    // 构建参数列表
        return f.apply(this, args);                 // 通过它调用f
    };
}

// 传给这个函数的参数会传到右侧
function partialRight(f, ...outerArgs){
    return function(...innerArgs){                  // 返回这个函数
        let args = [...innerArgs, ...outerArgs];    // 构建参数列表
        return f.apply(this, args);                 // 通过它调用f
    };
}

// 这个函数的参数列表作为一个模板，这个参数列表中的 undefined值
// 会被来自内部参数的值填充
function partial(f, ...outerArgs){
    return function(...innerArgs){   
        let args = [...outerArgs];    	// 外部参数模板的局部副本
        let innerIndex = 0;             // 下一个是哪个内部函数
        // 循环遍历 args，用内部参数填充 undefined 值
        for(let i = 0; i < args.length; i++){
            if(args[i] === undefined) args[i] = innerArgs[innerIndex++];
        }
        // 现在把剩余的内部参数加进去
        args.push(...innerArgs.slice(innerIndex));
        return f.apply(this, args);   
    };
}

// 下面是有3个参数的函数
const f = function(x,y,z) { return x * (y -z);};
// 以下3个部分应用的区别
partialLeft(f, 2)(3, 4)            // => -2：绑定第一个参数：2 * (3 - 4)
partialRight(f, 2)(3, 4)           // =>  6：绑定最后一个参数：3 * (4 - 2)
partial(f, undefined, 2)(3, 4)     // => -6：绑定中间的参数：3 * (2 - 4)
```

以上的部分应用函数允许在已经定义的函数基础上轻松定义其他函数，如

```js
const increment = partialLeft(sum, 1);
const cuberoot = partialRight(Math.pow, 1/3);
cuberoot(increment(26))            // => 3
```

也可以将部分应用的函数与其他高阶函数组合，如通过组合与部分应用定义 `not()` 函数

```js
const not = partialLeft(compose, x => !x);
const even = x => x % 2 === 0;
const odd = not(even);
const isNumber = not(isNaN);
odd(3) && isNumber(2)    // => true
```



### 函数记忆

在函数式编程中，缓存称为函数记忆

以下代码展示了高阶函数 `memoize()` 可以接收一个函数参数，然后返回这个函数的记忆版

```js
// 返回f的记忆版
// 只适用于f的参数都有完全不同的字符串表示的情况
function memoize(){
    const cache =new Map();    // cache保存在这个闭包中
    
    return function(...args){
        // 创建参数的字符串版，以用作缓存键
        let key = args.length + args.join("+");
        if(cache.has(key)){
            return cache.get(key);
        }else{
            let result = f.apply(this, args);
            cache.set(key, result);
            return result;
        }
    };
}
```

这个 `memoize()` 函数创建一个新对象作为缓存使用，并将这个对象赋值给一个局部变量，从而让其（在闭包中）成为被返回的函数的私有变量。返回的函数将其参数数组转换为字符串，并使用该字符串作为缓存对象的属性。若缓存存在某个值，直接返回该值；否则，调用指定函数计算这些参数值，然后缓存这个值，最后返回这个值，以为为使用上述函数实例

```js
// 使用欧几里得算法返回两个整数的最大公约数
function gcd(a,b){        // 省略了对a和b的类型检查
    if(a < b){            // 开始时保证a ≥ b
        [a, b] = [b, a];  
    }
    while(b !== 0){       // 欧几里得算法
        [a, b] = [b, a%b];
    }
    return a;
}

const gcdmemo = memoize(gcd);
gcdmemo(85, 187)          // => 17

// 在编写记忆的递归函数时，通常希望递归记忆版，而非原始版
const factorial = memoize(function(n){
    return (n <= 1) ? 1 : n * factorial(n-1);
});
factorial(5)              // => 120：也为4、3、2和1缓存了值
```

