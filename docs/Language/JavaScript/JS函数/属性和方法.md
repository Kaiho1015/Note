函数使用 `typeof` 操作符返回字符串 `function`，但函数实际上是一种特殊的对象，因此也有属性和方法，甚至构造函数

**`length` 属性**

- 函数有一个只读的 `length` 属性，表示函数的元数，即函数在参数列表中声明的形参个数
- 剩余形参不包含在 `length` 属性内



**`name` 属性**

- 函数有一个只读的 `name` 属性，表示定义函数时使用的名字
- 若函数是未命名的，表示在第一次创建此函数时赋给该函数的变量名或属性名
- 主要用于记录调试或排错消息



**`prototype` 属性**

- 除了箭头函数，所有函数都有一个 `prototype` 属性，这个属性引用原型对象的对象
- 每个函数都有原型对象
- 当函数被作为构造函数使用时，新创建的对象从这个原型对象继承属性



**`call()` 和 `apply()` 方法**

- `call()` 和 `apply()` 允许间接调用一个函数

- `call()` 和 `apply()` 的第一个参数为要在其上调用这个函数的对象，即函数的调用上下文，在函数体内会成为 `this` 关键字的值，箭头函数调用这两个方法会忽略第一个参数

  ```js
  // 函数 f() 对象 o
  f.call(o);
  f.apply(o);
  ```

- `call()` 的后续参数会传给被调用的函数，`apply()` 传给函数的参数需要以数组的形式提供

  ```js
  f.call(o, 1, 2);
  f.apply(o, [1,2]);
  ```

  

**`bind()` 方法**

- `bind()` 方法的主要目的是将函数绑定到对象

  ```js
  function f(y){ return this.x + y;}  // 需要绑定的函数
  let o = { x: 1};                    // 要绑定的对象
  let g = f.bind(o);                  // 调用g(x)会在o上调用f()
  g(2)                                // => 3
  let p = { x: 10, g};                // 作为这个对象的方法调用g()
  p.g(2)                              // => 3：g仍然绑定到o，而非p
  ```

- 调用 `bind()` 最常见的目的是让非箭头函数变得像箭头函数，箭头函数从定义的环境中继承 `this` 值，且不能被 `bind()` 覆盖

- `bind()` 方法也可以执行“部分应用”（柯里化），即在第一个参数之后传给 `bind()` 的参数也会随着 `this` 值一起被绑定

  ```js
  let sum = (x,y) => x + y;     
  let succ = sum.bind(null,1);
  succ(2)      // => 3：x绑定到1，2会传给参数y
  
  function f(y,z){ return this.x + y + z}
  let g = f.bind({x: 1}, 2);      // 绑定this和y
  g(3)         // => 6：this.x绑定到1，y绑定到2，z是3
  ```

  

**`Function()` 构造函数**

- `Function()` 构造函数可以接收任意多个字符串参数，其中最后一个参数是函数体的文本

- 与函数字面量一样，`Function()` 构造函数创建的也是匿名函数

- `Function()` 构造函数允许在运行时动态创建和编译 JavaScript 函数

- `Function()` 构造函数创建的函数不使用词法作用域，而是始终编译为如同顶级函数一样

  ```js
  let scope = "global";
  function constructFunction(){
      let scope = "local";
      return new Function("return scope");    // 不会捕获局部作用域
  }
  // 这行代码返回“global”，因为Function()构造函数返回的函数不使用局部作用域
  constructFunction()()          // => "global"
  ```

