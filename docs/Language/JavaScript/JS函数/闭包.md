JavaScript 使用词法作用域，即函数执行时使用的是定义函数时生效的变量作用域，而不是调用函数时生效的变量作用域

闭包：将函数对象与作用域（即一组绑定）组合起来解析函数变量的机制



闭包在嵌套函数中最为常见，且一个私有变量可以由多个闭包共享

```js
function conter(){
    let n = 0;
    return{
        count: function(){ return n++; },
        reset: function(){ n=0; }
    };
}
let c = counter(), d = counter();    // 创建两个计数器
c.count()
d.count()
c.reset();          // reset() 和 count() 方法共享状态
c.count()           // =>0：因为重置了 c
```

上述代码中 `counter()` 函数返回一个“计数器”对象，有两个方法。每次调用 `counter()` 都会创建一个新作用域，即 c 和 d 的变量不一样，在一个计数器上调用 `count()` 或 `reset()` 不会影响另一个计数器



闭包技术也可以与属性获取方法和设置方法组合使用

```js
function counter(n){
    return{
        // 属性获取方法，返回递增后的私有计数器值
        get count() { return n++; },
        // 属性设置方法，不允许 n 的值减少
        set count(m) {
            if (m > n) n = m;
            else throw Error("count can only be set to a larger value");
        }
    };
}
```



基于闭包技术实现一个通用的共享私有状态的函数，使用闭包的私有属性访问器方法

```js
// 这个函数按照指定的名字为对象 o 添加属性访问器方法
// 方法命名为 get<name> 和 set<name>
// 若提供断言函数，则设置方法用它测试自己的函数
// 在存储前先验证，若断言返回 false，则设置方法抛出异常

// 操作的值没有保存在对象 o 上，保存在这个函数的一个局部变量中
// 获取方法和设置方法也在函数局部定义，即可以访问这个局部变量
// 即该变量对两个访问器方法是私有的，除了设置方法，没有
// 其他途径可以设置或修改这个变量的值
function addPrivateProperty(o, name, predicate){
    let value;    // 属性值
    
    // 获取方法简单地返回属性值
    o[`get${name}`] = function(){ return value; };
    
    // 设置方法保存值或在断言失败时抛出异常
    o[`set${name}`] = function(v){
        if(predicate && !predicate(v)){
            throw new TypeError(`set${name}: invalid value ${v}`);
        }else{
            value = v;
        }
    };
}

// 使用 addPrivateProperty() 方法
let o = {};

// 添加属性访问器方法，并确保只能设置字符串值
addPrivateProperty(o, "Name", x => typeof x === "string");

o.setName("Frank");        // 设置属性的值
o.getName();               // => "Frank"
o.setName(0);              // !TypeError：尝试设置一个错误类型的值
```

