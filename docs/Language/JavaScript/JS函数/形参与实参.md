JavaScript 函数定义不会指定函数形参的类型，函数调用也不对传入的实参进行任何类型检查

### 可选形参与默认值

调用函数时传入的实参少于声明的形参时，额外的形参会获得默认值，通常是 `undefined`

```js
// 将对象 o 的可枚举属性名放到数组中，返回数组
// 若不传数组，创建一个新数组
function getPropertyNames(o, a = []){
    for(let property in o) a.push(property);
    return a;
}
```

函数的形参默认值表达式在函数调用时求值，因此每次调用上述函数时若只传一个参数，都创建并传入一个新的空数组

若函数有多个形参，可以使用前面参数的值来定义后面参数的默认值

```js
const rectangle = (width, height = width*2)
rectangle(1)        // => {width: 1, height: 2}
```



### 剩余实参与可变长度实参列表

剩余形参能够编写在调用时传入比形参多任意数量的实参的函数

```js
function max(first=-Infinity, ...rest){
    let maxValue = first;
    // 遍历其他参数，寻找最大数值
    for(let n of rest){
        if(n > maxValue){
            maxValue = n;
        }
    }
    // 返回最大的数值
    return maxValue;
}

max(1, 10, 100, 2, 3, 1000, 4)    // => 1000
```

剩余形参前有三个点，且必须是函数声明中最后一个参数

在函数体内，剩余形参的值始终是数组，数组可能为空，但剩余形参不可能为 `undefined`



### 函数实参解构为形参

调用函数时若传入一个实参列表，则所有参数值都会被赋给函数定义时声明的形参

```js
function vectorAdd(v1, v2){
    return [v1[0] + v2[0], v1[1] + v2[1]];
}
vectorAdd([1,2], [3,4])    // => [4,6]
```

在解构赋值中可以为形参定义默认值

```js
// 用标量乘以向量
function vetorMultiply({x, y, z=0}, scalar){
    return { x: x*scalar, y: y*scalar, z: z*scalar};
}
vectorMultiply({x: 1, y: 2}, 2)    // => {x: 2, y: 4, z: 0}
```

可以通过把对象参数解构为函数参数模拟调用函数时使用 `name=value` 的形式指定实参

```js
function arraycopy({from,to=from,n=from.length,fromIndex=0,toIndex=0}){
    let valuesToCopy = from.slice(fromIndex, fromIndex + n);
    to.splice(toIndex, 0, ...valuesToCopy);
    return to;
}
let a = [1,2,3,4,5], b=[9,8,7,6,5];
arraycopy({from: a, n: 3, to: b, toIndex: 4})    // => [9, 8, 7, 6, 1, 2, 3, 5]
```

ES2018 中，解构对象也可以使用形参

```js
function vetorMultiply({x, y, z=0, ...props}, scalar){
    return { x: x*scalar, y: y*scalar, z: z*scalar, ...props};
}
vectorMultiply({x: 1, y: 2, w: -1}, 2)    // => {x: 2, y: 4, z: 0, w: -1}
```