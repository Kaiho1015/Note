在最基本的层面，JavaScript 异步编程是基于回调实现的

回调即函数，可以传递给其他函数，其他函数在满足某个条件或发生某个（异步）事件时调用（回调）这个函数

### 定时器

一种最简单的异步操作即在一定时间后运行某些代码

```js
setTimeout(checkForUpdates, 60000);
```

`setTimeout()` 函数的第一个参数是一个函数，第二个参数是以毫秒为单位的时间间隔

`setTimeout()` 用来注册回调函数，还指定在什么异步条件下调用回调函数

`setTimeout()` 只会调用一次指定的回调函数，若需要重复运行，使用 `setInterval()` 

```js
// 1分钟后调用checkForUpdates，然后每过1分钟调用一次
let updateIntervalId = setInterval(checkForUpdates, 60000);

// setInterval()返回一个值，把这个值传给clearInterval()
// 可以停止这种重复调用（类似地，setTimeout()也返回一个值，
// 可以把它传给clearTimeout()）
function stopCheckingForUpdates(){
    clearInterval(updataIntervalld);
}
```



### 事件

客户端 JavaScript 编程几乎全都是事件驱动的，等待用户行为，然后响应用户的动作

事件驱动的 JavaScript 程序在特定上下文中为特定类型的事件注册回调函数，而浏览器在指定的事件发生时调用这些函数，这些回调函数叫做事件处理程序或事件监听器，通过 `addEventListener()` 注册

```js
// 浏览器返回一个对象，表示与下面的CSS选择符匹配的<button>元素
let okay = document.querySelector('#confirmUpdateDialog button.okey');

// 然后注册一个回调函数，当用户单击该按钮时会被调用
okey.addEventListener('click',applyUpadte);
```



### 网络事件

JavaScript 中常见的异步操作来源还可以是网络请求

``` js
// 从Web服务器获取数据
function getCurrentVersionNumber(versionCallback){    // 注意回调参数
    // 通过脚本向后端版本API发送一个HTTP请求
    let request = new XMLHeepRequest();
    request.open("GET","http://www.example.com/api/version");
    request.send();
    
    // 注册一个将在响应到达时调用的回调
    request.onload = function(){
        if(request.status === 200){
            // 如果HTTP状态码没问题，则取得版本号并调用回调
            let currentVersion = parseFloat(request.responseText);
            versionCallback(null, currentVersion);
        }else{
            // 否则，通过回调报告错误
            versionCallback(response.statusText, null);
        }
    };
    // 注册另一个将在网络出错时调用的回调
    request.onerror = request.ontimeout = function(e){
        versionCallback(e.type, null);
    };
}
```

客户端 JavaScript 代码可以使用 `XMLHttpRequest` 类及回调函数来发送 HTTP 请求并异步处理服务器返回的响应

> `XMLHttpRequest` 类在现代客户端 JavaScript 中，很大程度上已经被 `fetch()` API 取代

对于大多数 Web API（包括XMLHttpRequest），都可以通过在生成事件的对象上调用 `addEventListener()` 并将相关事件的名字传给回调函数来定义事件处理程序，也可以如上述代码，将回调函数赋值给这个对象的一个属性来注册事件监听器



### Node 中的回调与事件

Node.js 服务器端 JavaScript 环境底层就是异步的，定义了很多使用回调和事件的 API。

```js
// 读取文件内容的默认API是异步的，会在读取文件内容后调用一个回调函数
const fs = require("fs");     // "fs"模块有文件系统相关的API
let options = {
    // 默认选项填写
};

// 读取配置文件，然后调用回调函数
fs.readFile("config..json", "utf-8", (err, text) => {
    if(err){
        // 如果有错误，显示一条警告消息，但仍然继续
        console.warn("Could not read config file:", err);
    }else{
        // 否则，解析文件内容并赋值给选项对象
        Object.assign(options, JSON.parse(text));
    }
    
    // 无论是什么情况，都启动运行程序
    startProgram(options);
});
```

Node 的 `fs.readFile()` 函数参数

- filename（必选），表示要读取的文件名。
- encoding（可选），表示文件的字符编码。
- callback 是回调函数，用于接收文件的内容。



Node 也定义了一些基于事件的 API

```js
// 在Node中通过HTTP请求获取URL的内容
const https = require("https");

// 读取URL文本内容，将其异步传给回调
function getText(url, callback){
    // 对URL发送一个HTTP GET请求
    request = https.get(url);
    
    // 注册一个函数处理“response”事件
    request.on("response", response =>{
        // 这个响应事件意味着收到了响应头
        let httpStatus = response.statusCode;
        
        // 此时没有收到HTTP响应体
        // 因此还要注册几个事件处理程序，以便收到响应体时被调用
        response.setEncoding("utf-8");      // 应该Unicode文本
        let body = "";                      // 需要在这里积累
        
        // 每个响应体块就绪时都会调用这个事件处理程序
        response.on("data", chunk => { body += chunk; });
        
        // 响应完成时会调用这个事件处理程序
        response.on("end", ()=>{
            if(httpStatus === 200){         // 如果HTTP响应码没问题
                callback(null, body);       // 把响应体传给回调
            }else{                          // 否则传错误
                callback(httpStatus, null);
            }
        });
    });
    
    // 为底层网络错误注册一个事件处理程序
    request.on("error", (err) =>{
        callback(err, null);
    });
}
```

上述代码包含两层处理事件监听器的异步代码，Node 使用 `on()` 方法注册事件监听器