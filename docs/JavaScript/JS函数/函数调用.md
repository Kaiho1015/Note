构成函数体的 JavaScript 代码在调用函数的时候执行，JavaScript 函数可通过 5 种方式调用

- 作为函数
- 作为方法
- 作为构造函数
- 通过 call() 或 apply() 方法间接调用
- 通过 JavaScript 语言特性隐式调用（与常规书函数调用不同）



### 函数调用

对于常规函数调用，函数的返回值会变成调用表达式的值

- 若函数由于解释器到末尾返回，返回值为 `undefined`
- 若函数由于解释器执行到 `return` 语句返回，返回语句表达式值，若没有值返回 `undefined`

作为函数来调用的函数通常不会在定义中使用 `this` 关键字



### 方法调用

方法即对象的属性为函数时的函数

方法调用会调用上下文，属性访问表达式由两部分构成：对象和属性名。对象会成为调用上下文，函数体可以通过 `this` 引用这个对象

```js
let calculator = {
    operand1: 1,
    operand2: 2,
    add(){
        // 使用this关键字引用包含对象
        this.result = this.operand1 + this.operand2;
    }
};
calculator.add();
calculator.result;    // => 2
```

`this` 关键字不具有变量那样的作用域，除了箭头函数，嵌套函数不会继承包含函数的 `this` 值

- 嵌套方法被当作方法调用，`this` 值就是调用它的对象
- 嵌套方法（不是箭头函数）被当作函数调用，`this` 值是全局对象（非严格模式）或 `undefined`（严格模式）

```js
let o = {
    m:function(){
        let self = this;    // 将 this 值保存在变量中
        this === o;         // => true
        f();                // 调用嵌套函数
        
        function f(){
            this === o;     // => false：this 是全局对象或 undefined
            self === o;     // => true
        }
    }
};
```

在嵌套函数内，`this` 关键字不等于对象，解决技巧：

- 如上述代码将 `this` 值 赋给变量，在嵌套函数中，使用变量引用

- ES6 之后，使用箭头函数继承 `this` 值，函数表达式不会被提升，需要将定义放在对象方法调用嵌套函数代码前

  ```js
  const f = () => {
      this ===o;    // true
  };
  ```

- 调用嵌套函数的 `bind()` 函数，定义一个在指定对象上被隐式调用的新函数

  ```js
  const f = (function(){
      this === o    // true，因为将这个函数绑定到外部的 this
  }).bind(this);
  ```



### 构造函数调用

在函数或方法调用前加关键字 `new`，即为构造函数调用

构造函数调用会创建一个新的空对象，这个对象继承构造函数的 `prototype` 属性指定的对象



### 隐式函数调用

一些 JavaScript 语言特性看起来不像函数调用，但实际上会导致某些函数被调用

这些被隐式调用的函数，若产生 bug，副效应和性能问题都比常规函数更难排查

可能导致隐式函数调用的语言特性

- 若对象由获取方法或设置方法，查询或设置其属性值可能会调用这些方法
- 对象在字符串上下文中使用时，会调用对象的 `toString()` 方法，用于数值上下文时，会调用 `valueOf()` 方法
- 遍历可迭代对象的元素时，也会涉及一系列方法调用
- 标签模板字面量是一种伪装的函数调用
- 代理对象的行为完全由函数控制，其上的几乎任何操作都会导致一个函数被调用